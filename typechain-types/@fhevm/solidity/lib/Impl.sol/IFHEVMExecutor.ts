/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../../../../common";

export interface IFHEVMExecutorInterface extends utils.Interface {
  functions: {
    "cast(bytes32,uint8)": FunctionFragment;
    "fheAdd(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheBitAnd(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheBitOr(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheBitXor(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheDiv(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheEq(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheGe(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheGt(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheIfThenElse(bytes32,bytes32,bytes32)": FunctionFragment;
    "fheLe(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheLt(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheMax(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheMin(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheMul(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheNe(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheNeg(bytes32)": FunctionFragment;
    "fheNot(bytes32)": FunctionFragment;
    "fheRand(uint8)": FunctionFragment;
    "fheRandBounded(uint256,uint8)": FunctionFragment;
    "fheRem(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheRotl(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheRotr(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheShl(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheShr(bytes32,bytes32,bytes1)": FunctionFragment;
    "fheSub(bytes32,bytes32,bytes1)": FunctionFragment;
    "getInputVerifierAddress()": FunctionFragment;
    "trivialEncrypt(uint256,uint8)": FunctionFragment;
    "verifyCiphertext(bytes32,address,bytes,uint8)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "cast"
      | "fheAdd"
      | "fheBitAnd"
      | "fheBitOr"
      | "fheBitXor"
      | "fheDiv"
      | "fheEq"
      | "fheGe"
      | "fheGt"
      | "fheIfThenElse"
      | "fheLe"
      | "fheLt"
      | "fheMax"
      | "fheMin"
      | "fheMul"
      | "fheNe"
      | "fheNeg"
      | "fheNot"
      | "fheRand"
      | "fheRandBounded"
      | "fheRem"
      | "fheRotl"
      | "fheRotr"
      | "fheShl"
      | "fheShr"
      | "fheSub"
      | "getInputVerifierAddress"
      | "trivialEncrypt"
      | "verifyCiphertext"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "cast",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheAdd",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitAnd",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitOr",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitXor",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheDiv",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheEq",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGe",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGt",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheIfThenElse",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLe",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLt",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMax",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMin",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMul",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNe",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "fheNeg", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "fheNot", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "fheRand",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRandBounded",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRem",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotl",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotr",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShl",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShr",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheSub",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getInputVerifierAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "trivialEncrypt",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyCiphertext",
    values: [BytesLike, string, BytesLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "cast", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheAdd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitAnd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitOr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitXor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheDiv", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheEq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheIfThenElse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheLe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheLt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMax", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMul", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNeg", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRand", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheRandBounded",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheRem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheSub", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getInputVerifierAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trivialEncrypt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyCiphertext",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IFHEVMExecutor extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IFHEVMExecutorInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    cast(
      ct: BytesLike,
      toType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheAdd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheBitAnd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheBitOr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheBitXor(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheDiv(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheEq(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheGe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheGt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheIfThenElse(
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheLe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheLt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheMax(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheMin(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheMul(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheNe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheNeg(
      ct: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheNot(
      ct: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheRand(
      randType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheRandBounded(
      upperBound: BigNumberish,
      randType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheRem(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheRotl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheRotr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheShl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheShr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    fheSub(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getInputVerifierAddress(overrides?: CallOverrides): Promise<[string]>;

    trivialEncrypt(
      ct: BigNumberish,
      toType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    verifyCiphertext(
      inputHandle: BytesLike,
      callerAddress: string,
      inputProof: BytesLike,
      inputType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  cast(
    ct: BytesLike,
    toType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheAdd(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheBitAnd(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheBitOr(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheBitXor(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheDiv(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheEq(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheGe(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheGt(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheIfThenElse(
    control: BytesLike,
    ifTrue: BytesLike,
    ifFalse: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheLe(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheLt(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheMax(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheMin(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheMul(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheNe(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheNeg(
    ct: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheNot(
    ct: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheRand(
    randType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheRandBounded(
    upperBound: BigNumberish,
    randType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheRem(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheRotl(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheRotr(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheShl(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheShr(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  fheSub(
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getInputVerifierAddress(overrides?: CallOverrides): Promise<string>;

  trivialEncrypt(
    ct: BigNumberish,
    toType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  verifyCiphertext(
    inputHandle: BytesLike,
    callerAddress: string,
    inputProof: BytesLike,
    inputType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    cast(
      ct: BytesLike,
      toType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    fheAdd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheBitAnd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheBitOr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheBitXor(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheDiv(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheEq(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheGe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheGt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheIfThenElse(
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheLe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheLt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheMax(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheMin(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheMul(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheNe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheNeg(ct: BytesLike, overrides?: CallOverrides): Promise<string>;

    fheNot(ct: BytesLike, overrides?: CallOverrides): Promise<string>;

    fheRand(randType: BigNumberish, overrides?: CallOverrides): Promise<string>;

    fheRandBounded(
      upperBound: BigNumberish,
      randType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    fheRem(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheRotl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheRotr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheShl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheShr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    fheSub(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    getInputVerifierAddress(overrides?: CallOverrides): Promise<string>;

    trivialEncrypt(
      ct: BigNumberish,
      toType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    verifyCiphertext(
      inputHandle: BytesLike,
      callerAddress: string,
      inputProof: BytesLike,
      inputType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {};

  estimateGas: {
    cast(
      ct: BytesLike,
      toType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheAdd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheBitAnd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheBitOr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheBitXor(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheDiv(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheEq(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheGe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheGt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheIfThenElse(
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheLe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheLt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheMax(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheMin(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheMul(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheNe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheNeg(
      ct: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheNot(
      ct: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheRand(
      randType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheRandBounded(
      upperBound: BigNumberish,
      randType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheRem(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheRotl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheRotr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheShl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheShr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    fheSub(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getInputVerifierAddress(overrides?: CallOverrides): Promise<BigNumber>;

    trivialEncrypt(
      ct: BigNumberish,
      toType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    verifyCiphertext(
      inputHandle: BytesLike,
      callerAddress: string,
      inputProof: BytesLike,
      inputType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    cast(
      ct: BytesLike,
      toType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheAdd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheBitAnd(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheBitOr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheBitXor(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheDiv(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheEq(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheGe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheGt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheIfThenElse(
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheLe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheLt(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheMax(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheMin(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheMul(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheNe(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheNeg(
      ct: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheNot(
      ct: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheRand(
      randType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheRandBounded(
      upperBound: BigNumberish,
      randType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheRem(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheRotl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheRotr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheShl(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheShr(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fheSub(
      lhs: BytesLike,
      rhs: BytesLike,
      scalarByte: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getInputVerifierAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    trivialEncrypt(
      ct: BigNumberish,
      toType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    verifyCiphertext(
      inputHandle: BytesLike,
      callerAddress: string,
      inputProof: BytesLike,
      inputType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
